<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans" xml:lang="zh-Hans"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ying">
<meta name="description" content="理解相对估值的本质、倍数的四步检验框架、如何选择可比公司并控制差异">

<title>【第17章】相对估值的基本原理：倍数的正确使用方法 – Tech Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-597958c53c93a607afca12fd375c57ed.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-1b3db88def35042d172274863c1cdcf0.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-597958c53c93a607afca12fd375c57ed.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ea2c01f27a86cd888be845a75ab84aaf.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-6ee47bd5d569ce80d002539aadcc850f.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-ea2c01f27a86cd888be845a75ab84aaf.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script>
<!-- Force refresh if cache is stale -->

<script>

(function() {

  var SITE_VERSION = '2025-11-14-v2'; // Update this to force all users to refresh

  var stored = localStorage.getItem('site_version');

  if (stored !== SITE_VERSION) {

    localStorage.setItem('site_version', SITE_VERSION);

    if (stored !== null) {

      // Not first visit, force reload from server

      window.location.reload(true);

    }

  }

})();

</script>

<script>

// Default to dark scheme on first visit (no prior preference stored)

try {

  var key = 'quarto-color-scheme';

  if (window && window.localStorage && window.localStorage.getItem(key) === null) {

    window.localStorage.setItem(key, 'alternate');

  }

} catch (e) {

  // ignore storage errors (privacy mode, etc.)

}

</script>

<!-- Aggressive cache prevention for HTML pages -->

<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">

<meta http-equiv="Pragma" content="no-cache">

<meta http-equiv="Expires" content="0">

<meta name="revisit-after" content="1 days">

<meta name="robots" content="noarchive">




  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Tech Notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="搜索"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="展开或折叠导航栏" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../home.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts_en.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tags.html"> 
<span class="menu-text">Tags</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="切换深色模式"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">该页面内容</h2>
   
  <ul>
  <li><a href="#从一个问题开始" id="toc-从一个问题开始" class="nav-link active" data-scroll-target="#从一个问题开始"><span class="header-section-number">1</span> 从一个问题开始</a></li>
  <li><a href="#相对估值的使用" id="toc-相对估值的使用" class="nav-link" data-scroll-target="#相对估值的使用"><span class="header-section-number">2</span> 相对估值的使用</a>
  <ul class="collapse">
  <li><a href="#为什么如此流行" id="toc-为什么如此流行" class="nav-link" data-scroll-target="#为什么如此流行"><span class="header-section-number">2.1</span> 为什么如此流行？</a></li>
  <li><a href="#潜在的陷阱" id="toc-潜在的陷阱" class="nav-link" data-scroll-target="#潜在的陷阱"><span class="header-section-number">2.2</span> 潜在的陷阱</a></li>
  </ul></li>
  <li><a href="#标准化价值与倍数" id="toc-标准化价值与倍数" class="nav-link" data-scroll-target="#标准化价值与倍数"><span class="header-section-number">3</span> 标准化价值与倍数</a>
  <ul class="collapse">
  <li><a href="#盈利倍数" id="toc-盈利倍数" class="nav-link" data-scroll-target="#盈利倍数"><span class="header-section-number">3.1</span> 盈利倍数</a></li>
  <li><a href="#账面价值或重置价值倍数" id="toc-账面价值或重置价值倍数" class="nav-link" data-scroll-target="#账面价值或重置价值倍数"><span class="header-section-number">3.2</span> 账面价值或重置价值倍数</a></li>
  <li><a href="#收入倍数" id="toc-收入倍数" class="nav-link" data-scroll-target="#收入倍数"><span class="header-section-number">3.3</span> 收入倍数</a></li>
  <li><a href="#行业特定倍数" id="toc-行业特定倍数" class="nav-link" data-scroll-target="#行业特定倍数"><span class="header-section-number">3.4</span> 行业特定倍数</a></li>
  </ul></li>
  <li><a href="#使用倍数的四个基本步骤" id="toc-使用倍数的四个基本步骤" class="nav-link" data-scroll-target="#使用倍数的四个基本步骤"><span class="header-section-number">4</span> 使用倍数的四个基本步骤</a>
  <ul class="collapse">
  <li><a href="#定义测试一致性与统一性" id="toc-定义测试一致性与统一性" class="nav-link" data-scroll-target="#定义测试一致性与统一性"><span class="header-section-number">4.1</span> 定义测试：一致性与统一性</a></li>
  <li><a href="#描述测试了解倍数的分布" id="toc-描述测试了解倍数的分布" class="nav-link" data-scroll-target="#描述测试了解倍数的分布"><span class="header-section-number">4.2</span> 描述测试：了解倍数的分布</a></li>
  <li><a href="#分析测试理解倍数的决定因素" id="toc-分析测试理解倍数的决定因素" class="nav-link" data-scroll-target="#分析测试理解倍数的决定因素"><span class="header-section-number">4.3</span> 分析测试：理解倍数的决定因素</a></li>
  <li><a href="#应用测试可比公司与差异控制" id="toc-应用测试可比公司与差异控制" class="nav-link" data-scroll-target="#应用测试可比公司与差异控制"><span class="header-section-number">4.4</span> 应用测试：可比公司与差异控制</a></li>
  </ul></li>
  <li><a href="#调和相对估值与-dcf-估值" id="toc-调和相对估值与-dcf-估值" class="nav-link" data-scroll-target="#调和相对估值与-dcf-估值"><span class="header-section-number">5</span> 调和相对估值与 DCF 估值</a></li>
  <li><a href="#总结" id="toc-总结" class="nav-link" data-scroll-target="#总结"><span class="header-section-number">6</span> 总结</a></li>
  <li><a href="#思考题" id="toc-思考题" class="nav-link" data-scroll-target="#思考题"><span class="header-section-number">7</span> 思考题</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">【第17章】相对估值的基本原理：倍数的正确使用方法</h1>
  <div class="quarto-categories">
    <div class="quarto-category">金融</div>
    <div class="quarto-category">投资</div>
    <div class="quarto-category">估值</div>
  </div>
  </div>

<div>
  <div class="description">
    理解相对估值的本质、倍数的四步检验框架、如何选择可比公司并控制差异
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">作者</div>
    <div class="quarto-title-meta-contents">
             <p>Ying </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">发布于</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2025年12月17日</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="从一个问题开始" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="从一个问题开始"><span class="header-section-number">1</span> 从一个问题开始</h2>
<p>在前面的章节中，我们深入探讨了现金流折现估值（DCF）——根据资产的现金流、增长和风险特征来确定其价值。但在实践中，打开任何一份券商研究报告，你更可能看到的是这样的分析：</p>
<blockquote class="blockquote">
<p>“我们给予公司 20 倍 P/E，目标价 XX 元”</p>
<p>“公司 EV/EBITDA 为 8 倍，低于行业平均的 10 倍，存在重估空间”</p>
</blockquote>
<p>这就是<strong>相对估值</strong>（Relative Valuation）——根据市场上类似资产的当前定价来估计资产价值。</p>
<p>倍数（Multiples）易于使用、直观简洁，但也极易被滥用。本章将建立一套<strong>检验框架</strong>，帮助你正确使用倍数，并识别他人手中倍数的误用。</p>
<p>相对估值有两个核心组成部分：</p>
<ol type="1">
<li><strong>标准化价格</strong>：将价格转换为盈利、账面价值或收入的倍数</li>
<li><strong>寻找可比公司</strong>：这很困难，因为没有两家公司是完全相同的</li>
</ol>
<p>如何控制可比公司之间的差异，成为相对估值的关键问题。</p>
</section>
<section id="相对估值的使用" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="相对估值的使用"><span class="header-section-number">2</span> 相对估值的使用</h2>
<section id="为什么如此流行" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="为什么如此流行"><span class="header-section-number">2.1</span> 为什么如此流行？</h3>
<p>相对估值或定价被广泛使用，有几个原因：</p>
<p><strong>速度与简洁</strong></p>
<p>基于倍数和可比公司的定价，可以用更少的显式假设、更快的速度完成，远比 DCF 估值简单。</p>
<p><strong>易于沟通</strong></p>
<p>相对估值更容易理解，也更容易向客户展示。用倍数来说明一项资产是便宜还是昂贵，比用 DCF 估值要容易得多。</p>
<p><strong>反映市场情绪</strong></p>
<p>相对估值更可能反映当前的市场情绪，因为它衡量的是<strong>相对价值</strong>而非<strong>内在价值</strong>。在一个所有社交媒体股票都被追捧的市场中，相对估值可能会给出比 DCF 更高的定价。</p>
<p>这对于那些以相对业绩为考核标准的人尤为重要。比如成长型基金经理——他们的业绩是相对于其他成长型基金来衡量的。因此，即使所有成长股都被高估，只要他们能挑选出相对于其他成长股被低估的股票，他们就会获得奖励。</p>
</section>
<section id="潜在的陷阱" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="潜在的陷阱"><span class="header-section-number">2.2</span> 潜在的陷阱</h3>
<p>相对估值的优势也是它的劣势：</p>
<p><strong>容易导致不一致的估值</strong></p>
<p>快速组合一个倍数和一组可比公司的便利性，也可能导致忽视风险、增长或现金流潜力等关键变量。</p>
<p><strong>受市场整体偏差影响</strong></p>
<p>倍数反映市场情绪，这意味着当市场高估可比公司时，相对估值也会得出过高的价值；当市场低估时，结果也会过低。</p>
<p><strong>易于操纵</strong></p>
<p>虽然任何估值都有偏差的空间，但相对估值缺乏对底层假设的透明度，特别容易被操纵。一个有偏见的分析师，如果可以选择使用哪个倍数以及选择哪些可比公司，基本上可以得出任何他想要的结论。</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">警告</span>警惕操纵
</div>
</div>
<div class="callout-body-container callout-body">
<p>相对估值的简单性是一把双刃剑。精心挑选的可比公司组合和”合适”的倍数，可以让分析师证明几乎任何预设的结论。</p>
</div>
</div>
</section>
</section>
<section id="标准化价值与倍数" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="标准化价值与倍数"><span class="header-section-number">3</span> 标准化价值与倍数</h2>
<p>股票价格是公司股权价值和流通股数的函数。因此，一次 2:1 的拆股会使股价减半。由于股价取决于公司股权的单位数量，<strong>股价本身不能直接跨公司比较</strong>。</p>
<p>要比较市场上类似公司的定价，你需要<strong>标准化</strong>价格。价值可以相对于以下指标进行标准化：</p>
<ul>
<li>产生的盈利</li>
<li>资产的账面价值或重置价值</li>
<li>产生的收入</li>
<li>行业特定的指标</li>
</ul>
<section id="盈利倍数" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="盈利倍数"><span class="header-section-number">3.1</span> 盈利倍数</h3>
<p>将资产价值视为其产生盈利的倍数，是最直观的方式之一。</p>
<p><strong>股权视角</strong>：购买股票时，通常将支付的价格视为公司每股收益（EPS）的倍数。EPS 可以是： - 过去财年的 EPS（Current PE） - 过去四个季度的 EPS（Trailing PE） - 预期下一年的 EPS（Forward PE）</p>
<p><strong>企业视角</strong>：购买整个企业（而非仅股权）时，通常将运营资产价值（企业价值，Enterprise Value）视为营业利润或 EBITDA 的倍数。</p>
<p>对于买方来说，较低的倍数优于较高的倍数，但这些倍数会受到被收购企业的<strong>增长潜力和风险</strong>的影响。</p>
</section>
<section id="账面价值或重置价值倍数" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="账面价值或重置价值倍数"><span class="header-section-number">3.2</span> 账面价值或重置价值倍数</h3>
<p>市场提供了一种企业价值的估计，而会计师往往提供另一种截然不同的估计。账面价值由会计规则决定，主要受资产原始购买价格和此后的会计调整（如折旧）影响。</p>
<p>投资者经常关注<strong>市净率</strong>（Price-to-Book Value, PBV）来判断股票是高估还是低估。这个比率在不同行业之间差异很大，取决于增长潜力和投资质量。</p>
<p>对于那些认为账面价值不能很好地反映资产真实价值的人，一个替代方案是使用资产的<strong>重置成本</strong>。企业价值与重置成本的比率被称为 <strong>Tobin’s Q</strong>，将在第19章讨论。</p>
</section>
<section id="收入倍数" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="收入倍数"><span class="header-section-number">3.3</span> 收入倍数</h3>
<p>盈利和账面价值都是会计指标，由会计规则决定。收入（Revenue）是一个<strong>受会计选择影响较小</strong>的替代指标。</p>
<ul>
<li><strong>市销率</strong>（Price-to-Sales, PS）：股权市值 ÷ 收入</li>
<li><strong>企业价值销售比</strong>（EV/Sales）：企业价值 ÷ 收入</li>
</ul>
<p>收入倍数的优势在于，它使得比较不同市场、不同会计准则下的公司变得更容易。它在由亏损公司组成的行业中也特别有用。</p>
</section>
<section id="行业特定倍数" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="行业特定倍数"><span class="header-section-number">3.4</span> 行业特定倍数</h3>
<p>盈利、账面价值和收入倍数可以为任何行业的公司计算。但有些倍数是<strong>行业特定</strong>的。</p>
<p>例如，当互联网公司在 1990 年代后期首次出现时，它们没有盈利、收入和账面价值都可以忽略不计。分析师寻找一个倍数来估值这些公司，于是用公司市值除以网站点击量。点击量市值比较低的公司被视为更被低估。</p>
<p>更近的例子是 LinkedIn 和 Facebook 等社交媒体公司，市场用<strong>每用户市值</strong>来评估它们。</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">警告</span>行业特定倍数的危险
</div>
</div>
<div class="callout-body-container callout-body">
<p>行业特定倍数有两个危险：</p>
<ol type="1">
<li><p><strong>无法跨行业比较</strong>：由于不能为其他行业或整个市场计算，可能导致某个行业相对于市场其他部分被持续高估或低估。投资者可能不会考虑以收入 80 倍的价格购买一家公司，但可能会毫无顾虑地为每次页面点击支付 2,000 美元——因为他们不知道这个指标的高、低或平均水平是什么。</p></li>
<li><p><strong>难以与基本面挂钩</strong>：网站访问者能转化为更高的收入和利润吗？社交媒体网站上每增加一个用户能创造多少价值？答案不仅因公司而异，而且难以预测。</p></li>
</ol>
</div>
</div>
</section>
</section>
<section id="使用倍数的四个基本步骤" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="使用倍数的四个基本步骤"><span class="header-section-number">4</span> 使用倍数的四个基本步骤</h2>
<p>倍数易于使用，也易于误用。有四个基本步骤可以帮助你正确使用倍数，并识别他人手中的误用：</p>
<ol type="1">
<li><strong>定义测试</strong>（Definitional Tests）：确保倍数定义一致、计算统一</li>
<li><strong>描述测试</strong>（Descriptional Tests）：了解倍数的分布特征</li>
<li><strong>分析测试</strong>（Analytical Tests）：理解决定倍数的基本面因素</li>
<li><strong>应用测试</strong>（Application Tests）：找到正确的可比公司并控制差异</li>
</ol>
<section id="定义测试一致性与统一性" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="定义测试一致性与统一性"><span class="header-section-number">4.1</span> 定义测试：一致性与统一性</h3>
<p><strong>同一倍数可能有不同定义</strong></p>
<p>即使是最简单的倍数，不同分析师也可能有不同的定义。以 P/E 为例：</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>版本</th>
<th>分子</th>
<th>分母</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>当前 P/E</td>
<td>当前股价</td>
<td>最近财年 EPS</td>
</tr>
<tr class="even">
<td>滚动 P/E</td>
<td>当前股价</td>
<td>过去四季度 EPS</td>
</tr>
<tr class="odd">
<td>前瞻 P/E</td>
<td>当前股价</td>
<td>预期下一年 EPS</td>
</tr>
</tbody>
</table>
<p>此外，EPS 可以基于基本股份或完全稀释股份计算，可以包含或排除非经常性项目。</p>
<p>以 2024 年 5 月的 Nvidia 为例，使用不同定义得到的 P/E 差异巨大：</p>
<ul>
<li>基于稀释股份的上一财年 EPS：约 97 倍</li>
<li>基于稀释股份的滚动 12 个月 EPS：约 73 倍</li>
<li>基于稀释股份的 2024 前瞻 EPS：约 40 倍</li>
<li>基于稀释股份的 2025 前瞻 EPS：约 32 倍</li>
</ul>
<p>在盈利增长期，前瞻 P/E 会比滚动 P/E 低，滚动 P/E 又比当前 P/E 低。<strong>看多的分析师倾向于使用前瞻 P/E 来证明股票便宜，看空的分析师则使用当前 P/E 来证明倍数过高。</strong></p>
<p><strong>一致性原则</strong></p>
<p>每个倍数都有分子和分母：</p>
<ul>
<li><strong>分子</strong>可以是股权价值（市值）或企业价值（EV = 股权 + 债务 - 现金）</li>
<li><strong>分母</strong>可以是股权指标（EPS、净利润、股东权益）或企业指标（营业利润、EBITDA、投入资本）</li>
</ul>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">重要</span>核心原则
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>如果分子是股权价值，分母也必须是股权指标；如果分子是企业价值，分母也必须是企业指标。</strong></p>
<ul>
<li>✅ P/E：股权价值 ÷ 股权收益</li>
<li>✅ EV/EBITDA：企业价值 ÷ 税息折旧摊销前利润</li>
<li>❌ <strong>Price/EBITDA</strong>：股权价值 ÷ 企业收益（<strong>不一致！</strong>）</li>
</ul>
</div>
</div>
<p><strong>Price-to-EBITDA 的问题</strong></p>
<p>Price-to-EBITDA 是一个近年来有些追随者的倍数，但它的定义是<strong>不一致</strong>的——分子是股权价值，分母是属于整个企业的收益。</p>
<p>使用这个倍数的分析师可能会争辩，不一致无所谓，因为所有可比公司都用相同方式计算。但他们错了。如果名单上有些公司没有债务，有些公司债务很重，后者在 Price/EBITDA 基础上看起来会很便宜，但实际上可能被高估或定价合理。</p>
<p><strong>统一性</strong></p>
<p>在相对估值中，倍数需要为一组公司计算，然后进行比较。为了使比较有意义，<strong>倍数必须在所有公司中统一定义</strong>。如果一家公司使用滚动 P/E，其他公司也必须使用滚动 P/E。</p>
<p>使用当前 P/E 比较的一个问题是，不同公司可能有不同的财年结束日期。这可能导致一些公司的价格除以 7 月到 6 月的盈利，而其他公司除以 1 月到 12 月的盈利。</p>
<p>此外，会计准则的差异可能导致类似公司的盈利和账面价值数字截然不同，使跨市场比较变得困难。</p>
</section>
<section id="描述测试了解倍数的分布" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="描述测试了解倍数的分布"><span class="header-section-number">4.2</span> 描述测试：了解倍数的分布</h3>
<p>使用倍数时，了解该倍数在市场上的高值、低值和典型值是什么，是使用倍数的关键部分。</p>
<p><strong>分布特征</strong></p>
<p>许多使用倍数的分析师只关注自己行业内公司的排名，但缺乏对倍数在整个市场分布情况的了解。为什么软件分析师要关心公用事业股的市盈率？因为软件股和公用事业股都在竞争同一个投资美元，它们必须遵守相同的规则。</p>
<p>关键的分布统计包括：</p>
<ul>
<li><strong>平均值和标准差</strong>：起点，但只是开始</li>
<li><strong>中位数</strong>：由于倍数不能小于零但没有上限，分布是<strong>右偏</strong>的，平均值会高于中位数，<strong>中位数更能代表典型公司</strong></li>
<li><strong>百分位值</strong>：10%、25%、75%、90% 等百分位有助于判断什么是高或低</li>
</ul>
<p><strong>异常值与平均值</strong></p>
<p>倍数在上端没有限制，公司可能有 500、2000 甚至 10000 的市盈率。这可能发生在股价高企，或盈利下降到极低水平时。这些<strong>异常值会导致平均值不具代表性</strong>。</p>
<p>大多数服务在计算平均值时，要么剔除这些异常值，要么将倍数限制在某个固定数值以下（例如，P/E 超过 500 的公司被设为 500）。</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">注记</span>为什么用中位数而不是平均数？
</div>
</div>
<div class="callout-body-container callout-body">
<p>以 2024 年 5 月美国市场四个行业的 P/E 数据为例：</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>行业</th>
<th>平均 PE</th>
<th>中位 PE</th>
<th>汇总 PE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>基础化学</td>
<td>12.41</td>
<td>11.84</td>
<td>23.99</td>
</tr>
<tr class="even">
<td>银行</td>
<td>8.55</td>
<td>9.74</td>
<td>8.58</td>
</tr>
<tr class="odd">
<td>软件</td>
<td>88.72</td>
<td>55.57</td>
<td>20.02</td>
</tr>
<tr class="even">
<td>烟草</td>
<td>17.75</td>
<td>13.62</td>
<td>36.94</td>
</tr>
</tbody>
</table>
<p>软件行业的三个指标差异巨大，主要因为该行业有更多亏损公司和极端高 P/E 的公司。银行业的三个指标则非常接近。中位数通常是更可靠的比较基准。</p>
</div>
</div>
<p><strong>估计倍数时的偏差</strong></p>
<p>对于每个倍数，都有些公司无法计算。当 EPS 为负时，P/E 无意义。当计算一组公司的平均 P/E 时，亏损公司会从样本中剔除。</p>
<p>有三种解决方案：</p>
<ol type="1">
<li><strong>意识到偏差</strong>：在分析中调整平均 P/E 以反映亏损公司的剔除</li>
<li><strong>使用汇总值</strong>：汇总所有公司的市值和净利润（包括亏损公司），用汇总值计算 P/E</li>
<li><strong>使用可计算的倍数</strong>：P/E 的倒数——<strong>盈利收益率</strong>（Earnings Yield）可以为所有公司计算，包括亏损公司</li>
</ol>
</section>
<section id="分析测试理解倍数的决定因素" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="分析测试理解倍数的决定因素"><span class="header-section-number">4.3</span> 分析测试：理解倍数的决定因素</h3>
<p>在讨论相对估值为何受欢迎时，我们说它需要的假设比 DCF 少。这在表面上是对的，但实际上，相对估值和 DCF 估值需要<strong>同样多的假设</strong>。区别在于：相对估值的假设是<strong>隐含的、未说明的</strong>，而 DCF 的假设是<strong>显式的</strong>。</p>
<p>使用倍数前，你需要回答两个问题：</p>
<ol type="1">
<li>什么基本面因素决定了公司应该以什么倍数交易？</li>
<li>这些基本面的变化如何影响倍数？</li>
</ol>
<p><strong>决定因素</strong></p>
<p>在 DCF 估值章节中，我们观察到公司价值是三个变量的函数：</p>
<ul>
<li>产生现金流的能力</li>
<li>现金流的预期增长</li>
<li>现金流的不确定性（风险）</li>
</ul>
<p><strong>每个倍数——无论是盈利、收入还是账面价值的倍数——都是这三个变量的函数</strong>：风险、增长和现金流产生潜力。</p>
<p>要”看看引擎盖下面”，可以回到简单的 DCF 模型，推导出倍数的决定因素。</p>
<p><strong>从 Gordon Growth Model 推导 P/E</strong></p>
<p>从稳定增长股利折现模型开始：</p>
<p><span class="math display">\[
P_0 = \frac{D_1}{k_e - g}
\]</span></p>
<p>两边除以预期 EPS（<span class="math inline">\(E_1\)</span>）：</p>
<p><span class="math display">\[
\frac{P_0}{E_1} = \text{Forward PE} = \frac{D_1/E_1}{k_e - g} = \frac{\text{Payout Ratio}}{k_e - g}
\]</span></p>
<p>滚动 P/E 可以修改为：</p>
<p><span class="math display">\[
\text{Trailing PE} = \frac{\text{Payout Ratio} \times (1 + g)}{k_e - g}
\]</span></p>
<p><strong>从 Gordon Growth Model 推导 P/B</strong></p>
<p>两边除以每股账面价值（BV）：</p>
<p><span class="math display">\[
\frac{P_0}{BV} = \text{PBV} = \frac{\text{Payout Ratio} \times \text{ROE}}{k_e - g}
\]</span></p>
<p><strong>推导企业价值倍数</strong></p>
<p>稳定增长公司的运营资产价值：</p>
<p><span class="math display">\[
\text{EV} = \frac{\text{FCFF}_1}{\text{WACC} - g}
\]</span></p>
<p>因此：</p>
<p><span class="math display">\[
\frac{\text{EV}}{\text{FCFF}} = \frac{1}{\text{WACC} - g}
\]</span></p>
<p>由于 FCFF 是税后营业利润减去净资本支出和营运资本需求，EBIT、税后 EBIT 和 EBITDA 的倍数也可以类似推导。</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">重要</span>关键洞察
</div>
</div>
<div class="callout-body-container callout-body">
<p>这个分析的目的不是让你回去用 DCF 估值，而是<strong>理解可能导致同一行业公司倍数不同的变量</strong>。</p>
<p>如果你忽视这些变量，你可能会得出 P/E 为 8 的股票比 P/E 为 12 的股票便宜的结论，而真正的原因可能是后者有更高的预期增长；或者你可能认为 P/B 为 0.7 的股票比 P/B 为 1.5 的便宜，而真正的原因可能是后者有更高的 ROE。</p>
</div>
</div>
<p><strong>关系的非线性</strong></p>
<p>知道决定倍数的基本面因素是有用的第一步，但理解倍数如何随基本面变化同样重要。</p>
<p>例如，知道高增长公司有更高的 P/E 是不够的。如果你需要分析一家增长率是行业平均两倍的公司，它的 P/E 应该是行业平均的 1.5 倍、1.8 倍还是 2 倍？</p>
<p><strong>令人惊讶的是，大量分析假设倍数与基本面之间是线性关系。</strong> 例如，PEG（P/E 除以预期增长率）隐含假设 P/E 与增长率是线性相关的。</p>
<p>从 DCF 模型推导倍数的一个优势是，你可以通过保持其他条件不变、改变一个变量的值，来分析每个基本面变量与倍数之间的关系。</p>
<p><strong>伴随变量（Companion Variable）</strong></p>
<p>虽然决定倍数的变量可以从 DCF 模型中提取，但在解释每个倍数时，<strong>有一个变量是主导性的</strong>。这个变量被称为<strong>伴随变量</strong>，通常可以通过观察倍数如何在行业或整个市场中变化来识别。</p>
<p>在接下来的三章中，将识别从 P/E 到 EV/Sales 等最常用倍数的伴随变量，并在分析中使用它们。</p>
</section>
<section id="应用测试可比公司与差异控制" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="应用测试可比公司与差异控制"><span class="header-section-number">4.4</span> 应用测试：可比公司与差异控制</h3>
<p><strong>什么是可比公司？</strong></p>
<p>可比公司是指与被估值公司具有<strong>相似现金流、增长潜力和风险</strong>的公司。理想情况下，你可以通过观察一个在风险、增长和现金流方面完全相同的公司如何被定价来估值。</p>
<p>注意：<strong>这个定义中没有任何关于行业或部门的内容。</strong> 理论上，如果一家电信公司和一家软件公司在现金流、增长和风险方面完全相同，它们就可以相互比较。</p>
<p>然而，在大多数分析中，分析师将可比公司定义为同一行业的其他公司。隐含的假设是，同一行业的公司具有相似的风险、增长和现金流特征。</p>
<p><strong>样本选择的权衡</strong></p>
<p>在创建估值的同业组合时，你面临两种冲动：</p>
<ol type="1">
<li><strong>寻找高度相似的公司</strong>：例如，用美国娱乐软件公司与其他规模相似、增长潜力相似的美国娱乐软件公司比较</li>
<li><strong>获得足够大的样本</strong>：让大数定律发挥作用，使个别公司的错误能够相互抵消</li>
</ol>
<p>这两种冲动是相互矛盾的。添加更多筛选标准会导致样本变小。</p>
<p>如果你只是简单地将公司的倍数与同业组合的中位数比较，小样本可能更好。但如果你有<strong>控制差异的机制</strong>，选择一个更大但存在差异的同业组合，会比一个更小、更同质的组合更可靠。</p>
<p><strong>控制差异的三种方法</strong></p>
<p>无论你多么仔细地构建可比公司列表，最终都会得到与被估值公司不同的公司。你需要控制这些差异。</p>
<p><strong>方法一：主观调整</strong></p>
<p>计算可比公司的倍数平均值，然后将个别公司的倍数与平均值比较。如果显著不同，主观判断公司的个别特征（增长、风险、现金流）是否能解释这种差异。</p>
<p>但这种方法有问题。当故事单独用于证明溢价或折价时，它们是不受约束的，使投资者和分析师能够确认自己的偏见。例如，2024 年 5 月，Nvidia 的滚动 P/E 超过 100，是当时半导体公司中位 P/E 的三倍多。一个想买入 Nvidia 的投资者可以用更高的盈利增长来证明支付更高 P/E 的合理性，而无需考虑更高的增长是否真的能证明如此大的溢价。</p>
<p><strong>方法二：修正倍数</strong></p>
<p>通过修正倍数来考虑决定它的最重要变量——伴随变量。</p>
<p>例如，P/E 除以预期 EPS 增长率，得到<strong>增长调整后的 P/E</strong>，即 <strong>PEG</strong>：</p>
<p><span class="math display">\[
\text{PEG} = \frac{\text{PE}}{\text{Expected Growth Rate}}
\]</span></p>
<p>这些修正后的倍数然后在公司之间进行比较。隐含的假设是，这些公司在除了被控制的变量之外的所有价值指标上都是可比的，并且倍数与基本面之间的关系是<strong>线性的</strong>。</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">注记</span>案例：2001 年饮料公司的 PE 与增长率比较
</div>
</div>
<div class="callout-body-container callout-body">
<table class="caption-top table">
<thead>
<tr class="header">
<th>公司</th>
<th>滚动 PE</th>
<th>预期增长率</th>
<th>标准差</th>
<th>PEG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Coca-Cola Bottling</td>
<td>29.18</td>
<td>9.50%</td>
<td>20.58%</td>
<td>3.07</td>
</tr>
<tr class="even">
<td>Molson Inc.&nbsp;Ltd.&nbsp;“A”</td>
<td>43.65</td>
<td>15.50%</td>
<td>21.88%</td>
<td>2.82</td>
</tr>
<tr class="odd">
<td>Anheuser-Busch</td>
<td>24.31</td>
<td>11.00%</td>
<td>22.92%</td>
<td>2.21</td>
</tr>
<tr class="even">
<td>Andres Wines Ltd.&nbsp;“A”</td>
<td>8.96</td>
<td>3.50%</td>
<td>24.70%</td>
<td>2.56</td>
</tr>
<tr class="odd">
<td>Brown-Forman “B”</td>
<td>10.07</td>
<td>11.50%</td>
<td>29.43%</td>
<td>0.88</td>
</tr>
<tr class="even">
<td>PepsiCo, Inc.</td>
<td>33.00</td>
<td>10.50%</td>
<td>31.35%</td>
<td>3.14</td>
</tr>
<tr class="odd">
<td>Coca-Cola</td>
<td>44.33</td>
<td>19.00%</td>
<td>35.51%</td>
<td>2.33</td>
</tr>
<tr class="even">
<td>Boston Beer “A”</td>
<td>10.59</td>
<td>17.13%</td>
<td>39.58%</td>
<td>0.62</td>
</tr>
<tr class="odd">
<td>Hansen Natural Corp.</td>
<td>9.70</td>
<td>17.00%</td>
<td>62.45%</td>
<td>0.57</td>
</tr>
<tr class="even">
<td><strong>行业平均</strong></td>
<td><strong>22.66</strong></td>
<td><strong>12.60%</strong></td>
<td><strong>33.30%</strong></td>
<td><strong>2.00</strong></td>
</tr>
</tbody>
</table>
<p>Andres Wines 的 P/E 为 8.96，显著低于行业平均的 22.66。简单看倍数，你会认为它被低估了。</p>
<p>但使用 PEG 方法，基于行业平均 PEG 2.00 和 Andres Wines 的增长率 3.50%，其”应有”的 P/E 为：</p>
<p><span class="math display">\[
\text{PE} = 2.00 \times 3.50\% = 7.00
\]</span></p>
<p>基于调整后的 P/E，Andres Wines 看起来反而<strong>高估</strong>了，尽管它有一个低 P/E。</p>
<p>但这个结论只有在这些公司<strong>风险相当</strong>时才成立。而且，这种方法隐含假设增长率与 P/E 之间是线性关系。</p>
</div>
</div>
<p><strong>方法三：回归分析</strong></p>
<p>当公司在多个变量上存在差异时，很难通过修正倍数来考虑所有差异。你可以将倍数作为因变量，对你认为决定该倍数的变量进行回归，然后用回归来预测每家公司的预期值。</p>
<p>这种方法在可比公司数量较多、倍数与变量之间关系稳定时效果较好。</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">注记</span>案例：饮料行业的行业回归
</div>
</div>
<div class="callout-body-container callout-body">
<p>由于饮料公司在风险和增长上都有差异，可以对 P/E 与这两个变量进行回归：</p>
<p><span class="math display">\[
\text{PE} = 20.87 - 63.98 \times \text{标准差} + 183.24 \times \text{预期增长率} \quad R^2 = 51\%
\]</span></p>
<p>括号中的数字是 t 统计量：(3.01)、(2.63)、(3.66)，表明关系在统计上是显著的。</p>
<p>用这个回归预测 Coca-Cola 的 P/E，基于其 35.51% 的标准差和 19% 的预期增长率：</p>
<p><span class="math display">\[
\text{预测 PE}_{\text{Coca-Cola}} = 20.87 - 63.98 \times 0.3551 + 183.24 \times 0.19 = 32.97
\]</span></p>
<p>由于 Coca-Cola 的实际 P/E 是 44.33，这表明<strong>相对于行业其他公司的定价，该股票被高估了</strong>。</p>
</div>
</div>
<p><strong>市场回归</strong></p>
<p>在行业内搜索可比公司有很大的局限性，特别是当行业内公司较少，或公司跨多个行业经营时。</p>
<p>由于可比公司的定义不是”同一行业”，而是”具有相同增长、风险和现金流特征”，你不必将可比公司限制在同一行业。</p>
<p>你可以用<strong>市场上所有公司</strong>作为样本，对任何倍数（PE、EV/EBITDA、PBV）与决定它的变量进行回归。然后用市场回归来预测个别公司的值。P/E 低于（高于）市场回归预测值的公司，相对于市场是被低估（高估）的。</p>
<p>市场回归的优势：</p>
<ol type="1">
<li><strong>量化关系</strong>：基于实际市场数据量化增长或风险对倍数的影响程度</li>
<li><strong>解决小样本问题</strong>：允许对少数公司组成的行业进行有意义的比较</li>
<li><strong>检测行业偏差</strong>：可以检查整个行业是否相对于市场被高估或低估</li>
</ol>
</section>
</section>
<section id="调和相对估值与-dcf-估值" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="调和相对估值与-dcf-估值"><span class="header-section-number">5</span> 调和相对估值与 DCF 估值</h2>
<p>两种估值方法——DCF 估值和相对估值——通常会对同一家公司给出不同的价值估计。即使在相对估值内部，使用不同的倍数或不同的可比公司，也可能得出不同的估计值。</p>
<p><strong>两种方法的核心差异</strong></p>
<p>DCF 估值和相对估值之间的差异来自<strong>对市场效率的不同看法</strong>：</p>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 45%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>DCF 估值</th>
<th>相对估值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>假设</strong></td>
<td>市场会犯错，但会随时间纠正</td>
<td>市场对个股可能犯错，但平均而言是正确的</td>
</tr>
<tr class="even">
<td><strong>错误范围</strong></td>
<td>可能是整个行业或整个市场</td>
<td>个别股票</td>
</tr>
<tr class="odd">
<td><strong>参照系</strong></td>
<td>内在价值</td>
<td>可比公司的市场定价</td>
</tr>
</tbody>
</table>
<p>因此，<strong>一只股票可能在 DCF 基础上被高估，但在相对基础上被低估</strong>——如果用于相对估值的公司都被市场高估了。反之亦然——如果整个行业或市场被低估，相对估值会给出比 DCF 更低的值。</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">重要</span>两种方法的调和
</div>
</div>
<div class="callout-body-container callout-body">
<p>当 DCF 和相对估值给出不同结果时：</p>
<ul>
<li><strong>DCF 显示低估，相对估值显示合理</strong>：可能整个行业被高估，或你的 DCF 假设过于乐观</li>
<li><strong>DCF 显示合理，相对估值显示低估</strong>：可能公司有市场尚未认识到的问题，或可比公司选择有偏差</li>
</ul>
<p><strong>最佳实践</strong>：两种方法都做。如果结论一致，信心更强；如果不一致，深入分析差异的原因。</p>
</div>
</div>
</section>
<section id="总结" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="总结"><span class="header-section-number">6</span> 总结</h2>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">重要</span>核心要点
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><strong>相对估值的本质</strong>：通过将价格标准化为倍数，比较类似资产的相对价值</li>
<li><strong>标准化方式</strong>：盈利倍数、账面价值倍数、收入倍数、行业特定倍数</li>
<li><strong>一致性原则</strong>：倍数的分子分母必须对应同一群体（股权 vs 企业价值）</li>
<li><strong>四步检验框架</strong>：定义测试 → 描述测试 → 分析测试 → 应用测试</li>
<li><strong>倍数的决定因素</strong>：每个倍数都是风险、增长和现金流产生潜力的函数——与 DCF 同源</li>
<li><strong>控制差异</strong>：主观调整、修正倍数（如 PEG）、回归分析</li>
<li><strong>与 DCF 的调和</strong>：两种方法基于对市场效率的不同假设，结果不同时需要深入分析原因</li>
</ul>
</div>
</div>
<p>本章我们回答了开头提出的问题：虽然倍数的简单性是其魅力所在，但正确使用它需要四个步骤。首先，一致地定义倍数并统一计算；其次，了解倍数在市场上的分布特征；第三，识别决定倍数的基本面变量以及这些变量的变化如何影响倍数；最后，找到真正可比的公司并调整基本面特征的差异。</p>
<p>关键的 takeaway 是：<strong>相对估值的假设并不比 DCF 少，它只是把假设隐藏在了可比公司的选择中。</strong></p>
</section>
<section id="思考题" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="思考题"><span class="header-section-number">7</span> 思考题</h2>
<ol type="1">
<li><p><strong>PE 的定义</strong>：你可以用当前盈利、滚动盈利或前瞻盈利计算 P/E。</p>
<ul>
<li>这些比率有什么区别？</li>
<li>哪一个可能产生最高的值？为什么？</li>
</ul></li>
<li><p><strong>一致性问题</strong>：某分析师计算了一个”企业价值/税后净利润”的比率（企业价值定义为市值加长期债务减现金）。</p>
<ul>
<li>解释为什么这个比率定义不一致。</li>
<li>解释为什么用这个倍数比较公司可能有问题。</li>
</ul></li>
<li><p><strong>分布特征</strong>：本章指出倍数具有偏斜分布。</p>
<ul>
<li>什么是偏斜分布？</li>
<li>为什么倍数通常有偏斜分布？</li>
<li>这对使用行业平均值比较公司的分析师有什么影响？</li>
</ul></li>
<li><p><strong>亏损公司的处理</strong>：通常我们无法为负盈利的公司计算 P/E。这对行业平均 P/E 等统计数据有什么影响？如何解决这个问题？</p></li>
<li><p><strong>实践应用</strong>：选择一个你熟悉的行业，尝试应用本章的四步框架。你在每一步遇到了什么挑战？</p></li>
</ol>


</section>

</main> <!-- /main -->
﻿<script>

// Simple EN / 中文 language toggle for posts; robust via meta[quarto:offset]

(function() {

  const KEY = 'siteLang'; // 'en' | 'zh'

  const defaultLang = 'en';

  const POSTS_EN = 'posts_en.html';

  const POSTS_ZH = 'posts_zh.html';

  const TAGS = 'tags.html';



  function currentLang() { try { return localStorage.getItem(KEY) || defaultLang; } catch(e) { return defaultLang; } }

  function setLang(v) { try { localStorage.setItem(KEY, v); } catch(e) {} }

  function offset() {

    const meta = document.querySelector('meta[name="quarto:offset"]');

    const off = meta && meta.getAttribute('content') ? meta.getAttribute('content') : './';

    return off;

  }

  function targetFor(lang) { return lang === 'zh' ? POSTS_ZH : POSTS_EN; }

  function goToLang(lang) {

    const off = offset();

    const path = window.location.pathname;

    setLang(lang);

    if (path.endsWith('/' + TAGS) || path.endsWith(TAGS)) {

      window.location.href = off + TAGS;

    } else {

      window.location.href = off + targetFor(lang);

    }

  }

  function updateNavbarPostsLink() {

    const off = offset();

    const href = off + targetFor(currentLang());

    const links = document.querySelectorAll('header .navbar a.nav-link');

    links.forEach((a) => {

      const h = a.getAttribute('href') || '';

      if (h.endsWith(POSTS_EN) || h.endsWith(POSTS_ZH)) a.setAttribute('href', href);

    });

  }

  function mountToggle() {

    const tools = document.querySelector('.quarto-navbar-tools');

    if (!tools) return;

    const wrapper = document.createElement('div');

    wrapper.style.display = 'inline-flex';

    wrapper.style.alignItems = 'center';

    wrapper.style.gap = '0.35rem';

    wrapper.style.marginLeft = '0.35rem';



    const en = document.createElement('a');

    en.href = '';

    en.textContent = 'EN';

    en.className = 'quarto-navigation-tool px-1';

    en.onclick = function(){ goToLang('en'); return false; };



    const sep = document.createElement('span');

    sep.textContent = '|';

    sep.style.opacity = '0.6';



    const zh = document.createElement('a');

    zh.href = '';

    zh.textContent = '中文';

    zh.className = 'quarto-navigation-tool px-1';

    zh.onclick = function(){ goToLang('zh'); return false; };



    const lang = currentLang();

    (lang === 'en' ? en : zh).style.fontWeight = '700';



    wrapper.appendChild(en);

    wrapper.appendChild(sep);

    wrapper.appendChild(zh);

    tools.appendChild(wrapper);

    updateNavbarPostsLink();

  }

  document.addEventListener('DOMContentLoaded', mountToggle);

})();

</script>

<script>

(function(){

  function offset(){

    var meta = document.querySelector('meta[name="quarto:offset"]');

    return meta && meta.getAttribute('content') ? meta.getAttribute('content') : './';

  }

  document.addEventListener('DOMContentLoaded', function(){

    var brand = document.querySelector('header .navbar a.navbar-brand');

    if (brand) {

      brand.setAttribute('href', offset() + 'home.html');

    }

  });

})();

</script>



<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "已复制");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "已复制");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>